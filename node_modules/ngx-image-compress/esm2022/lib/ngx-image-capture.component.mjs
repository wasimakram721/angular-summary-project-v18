import { Component, EventEmitter, Output, ViewChild } from '@angular/core';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common";
export class NgxImageCaptureComponent {
    constructor() {
        this.imageCaptured = new EventEmitter();
        this.errorCapture = new EventEmitter();
        this.videoElement = null;
        this.videoStream = ViewChild('video', { static: false });
        this.streamOpened = false;
    }
    startVideoCapture() {
        this.streamOpened = true;
        const constraints = {
            audio: false,
            video: {
                width: { ideal: 1920 },
                height: { ideal: 1080 },
                facingMode: { ideal: 'user' },
            },
        };
        navigator.mediaDevices
            .getUserMedia(constraints)
            .then(stream => {
            this.videoStream = stream;
            setTimeout(() => {
                if (this.videoElement && this.videoElement.nativeElement) {
                    this.videoElement.nativeElement.srcObject = stream;
                }
            }, 100);
        })
            .catch(error => {
            this.errorCapture.emit(`Ngx Image Compress: Could not access the camera. ${error}`);
            this.streamOpened = true;
        });
    }
    acquireImage() {
        const canvas = document.createElement('canvas');
        const video = this.videoElement && this.videoElement.nativeElement;
        if (!video) {
            this.errorCapture.emit('Ngx Image Compress - Error in acquisition of video element.');
            this.streamOpened = false;
            return;
        }
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        const context2d = canvas.getContext('2d');
        if (context2d)
            context2d.drawImage(video, 0, 0);
        const newImage = canvas.toDataURL('jpg', 95);
        if (this.videoStream) {
            this.videoStream.getVideoTracks().forEach(track => track.stop());
        }
        this.imageCaptured.emit(newImage);
        this.streamOpened = false;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.1.1", ngImport: i0, type: NgxImageCaptureComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.1.1", type: NgxImageCaptureComponent, selector: "ngx-image-capture", outputs: { imageCaptured: "imageCaptured", errorCapture: "errorCapture" }, viewQueries: [{ propertyName: "videoElement", first: true, predicate: ["video"], descendants: true }], ngImport: i0, template: `
        <span (click)="startVideoCapture()" *ngIf="!streamOpened">
            <ng-content select="[openStreamBtn]"></ng-content>
        </span>
        <span (click)="acquireImage()" *ngIf="streamOpened">
            <ng-content select="[acquireImageBtn]"></ng-content>
        </span>
        <video #video autoplay *ngIf="streamOpened"></video>
    `, isInline: true, dependencies: [{ kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.1.1", ngImport: i0, type: NgxImageCaptureComponent, decorators: [{
            type: Component,
            args: [{ selector: 'ngx-image-capture', template: `
        <span (click)="startVideoCapture()" *ngIf="!streamOpened">
            <ng-content select="[openStreamBtn]"></ng-content>
        </span>
        <span (click)="acquireImage()" *ngIf="streamOpened">
            <ng-content select="[acquireImageBtn]"></ng-content>
        </span>
        <video #video autoplay *ngIf="streamOpened"></video>
    ` }]
        }], propDecorators: { imageCaptured: [{
                type: Output
            }], errorCapture: [{
                type: Output
            }], videoElement: [{
                type: ViewChild,
                args: ['video', { static: false }]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LWltYWdlLWNhcHR1cmUuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vcHJvamVjdHMvbmd4LWltYWdlLWNvbXByZXNzL3NyYy9saWIvbmd4LWltYWdlLWNhcHR1cmUuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBQyxTQUFTLEVBQWMsWUFBWSxFQUFFLE1BQU0sRUFBRSxTQUFTLEVBQUMsTUFBTSxlQUFlLENBQUM7OztBQWdCckYsTUFBTSxPQUFPLHdCQUF3QjtJQWJyQztRQWNjLGtCQUFhLEdBQUcsSUFBSSxZQUFZLEVBQVcsQ0FBQztRQUM1QyxpQkFBWSxHQUFHLElBQUksWUFBWSxFQUFVLENBQUM7UUFHcEQsaUJBQVksR0FBd0MsSUFBSSxDQUFDO1FBQ3pELGdCQUFXLEdBQXVCLFNBQVMsQ0FBQyxPQUFPLEVBQUUsRUFBQyxNQUFNLEVBQUUsS0FBSyxFQUFDLENBQUMsQ0FBQztRQUN0RSxpQkFBWSxHQUFHLEtBQUssQ0FBQztLQWlEeEI7SUEvQ0csaUJBQWlCO1FBQ2IsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUM7UUFFekIsTUFBTSxXQUFXLEdBQUc7WUFDaEIsS0FBSyxFQUFFLEtBQUs7WUFDWixLQUFLLEVBQUU7Z0JBQ0gsS0FBSyxFQUFFLEVBQUMsS0FBSyxFQUFFLElBQUksRUFBQztnQkFDcEIsTUFBTSxFQUFFLEVBQUMsS0FBSyxFQUFFLElBQUksRUFBQztnQkFDckIsVUFBVSxFQUFFLEVBQUMsS0FBSyxFQUFFLE1BQU0sRUFBQzthQUM5QjtTQUNKLENBQUM7UUFFRixTQUFTLENBQUMsWUFBWTthQUNqQixZQUFZLENBQUMsV0FBVyxDQUFDO2FBQ3pCLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRTtZQUNYLElBQUksQ0FBQyxXQUFXLEdBQUcsTUFBTSxDQUFDO1lBQzFCLFVBQVUsQ0FBQyxHQUFHLEVBQUU7Z0JBQ1osSUFBSSxJQUFJLENBQUMsWUFBWSxJQUFJLElBQUksQ0FBQyxZQUFZLENBQUMsYUFBYSxFQUFFLENBQUM7b0JBQ3ZELElBQUksQ0FBQyxZQUFZLENBQUMsYUFBYSxDQUFDLFNBQVMsR0FBRyxNQUFNLENBQUM7Z0JBQ3ZELENBQUM7WUFDTCxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUM7UUFDWixDQUFDLENBQUM7YUFDRCxLQUFLLENBQUMsS0FBSyxDQUFDLEVBQUU7WUFDWCxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxvREFBb0QsS0FBSyxFQUFFLENBQUMsQ0FBQztZQUNwRixJQUFJLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQztRQUM3QixDQUFDLENBQUMsQ0FBQztJQUNYLENBQUM7SUFFRCxZQUFZO1FBQ1IsTUFBTSxNQUFNLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUNoRCxNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsWUFBWSxJQUFJLElBQUksQ0FBQyxZQUFZLENBQUMsYUFBYSxDQUFDO1FBQ25FLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQztZQUNULElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLDZEQUE2RCxDQUFDLENBQUM7WUFDdEYsSUFBSSxDQUFDLFlBQVksR0FBRyxLQUFLLENBQUM7WUFDMUIsT0FBTztRQUNYLENBQUM7UUFDRCxNQUFNLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQyxVQUFVLENBQUM7UUFDaEMsTUFBTSxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUMsV0FBVyxDQUFDO1FBQ2xDLE1BQU0sU0FBUyxHQUFHLE1BQU0sQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDMUMsSUFBSSxTQUFTO1lBQUUsU0FBUyxDQUFDLFNBQVMsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQ2hELE1BQU0sUUFBUSxHQUFHLE1BQU0sQ0FBQyxTQUFTLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBQzdDLElBQUksSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDO1lBQ25CLElBQUksQ0FBQyxXQUFXLENBQUMsY0FBYyxFQUFFLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUM7UUFDckUsQ0FBQztRQUNELElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQ2xDLElBQUksQ0FBQyxZQUFZLEdBQUcsS0FBSyxDQUFDO0lBQzlCLENBQUM7OEdBdkRRLHdCQUF3QjtrR0FBeEIsd0JBQXdCLDJPQVh2Qjs7Ozs7Ozs7S0FRVDs7MkZBR1Esd0JBQXdCO2tCQWJwQyxTQUFTOytCQUNJLG1CQUFtQixZQUNuQjs7Ozs7Ozs7S0FRVDs4QkFJUyxhQUFhO3NCQUF0QixNQUFNO2dCQUNHLFlBQVk7c0JBQXJCLE1BQU07Z0JBR1AsWUFBWTtzQkFEWCxTQUFTO3VCQUFDLE9BQU8sRUFBRSxFQUFDLE1BQU0sRUFBRSxLQUFLLEVBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0NvbXBvbmVudCwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBPdXRwdXQsIFZpZXdDaGlsZH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0RhdGFVcmx9IGZyb20gJy4vbW9kZWxzL2RhdGEtdXJsJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICduZ3gtaW1hZ2UtY2FwdHVyZScsXG4gICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPHNwYW4gKGNsaWNrKT1cInN0YXJ0VmlkZW9DYXB0dXJlKClcIiAqbmdJZj1cIiFzdHJlYW1PcGVuZWRcIj5cbiAgICAgICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cIltvcGVuU3RyZWFtQnRuXVwiPjwvbmctY29udGVudD5cbiAgICAgICAgPC9zcGFuPlxuICAgICAgICA8c3BhbiAoY2xpY2spPVwiYWNxdWlyZUltYWdlKClcIiAqbmdJZj1cInN0cmVhbU9wZW5lZFwiPlxuICAgICAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiW2FjcXVpcmVJbWFnZUJ0bl1cIj48L25nLWNvbnRlbnQ+XG4gICAgICAgIDwvc3Bhbj5cbiAgICAgICAgPHZpZGVvICN2aWRlbyBhdXRvcGxheSAqbmdJZj1cInN0cmVhbU9wZW5lZFwiPjwvdmlkZW8+XG4gICAgYCxcbiAgICBzdHlsZXM6IFtdLFxufSlcbmV4cG9ydCBjbGFzcyBOZ3hJbWFnZUNhcHR1cmVDb21wb25lbnQge1xuICAgIEBPdXRwdXQoKSBpbWFnZUNhcHR1cmVkID0gbmV3IEV2ZW50RW1pdHRlcjxEYXRhVXJsPigpO1xuICAgIEBPdXRwdXQoKSBlcnJvckNhcHR1cmUgPSBuZXcgRXZlbnRFbWl0dGVyPHN0cmluZz4oKTtcblxuICAgIEBWaWV3Q2hpbGQoJ3ZpZGVvJywge3N0YXRpYzogZmFsc2V9KVxuICAgIHZpZGVvRWxlbWVudDogRWxlbWVudFJlZjxIVE1MVmlkZW9FbGVtZW50PiB8IG51bGwgPSBudWxsO1xuICAgIHZpZGVvU3RyZWFtOiBNZWRpYVN0cmVhbSB8IG51bGwgPSBWaWV3Q2hpbGQoJ3ZpZGVvJywge3N0YXRpYzogZmFsc2V9KTtcbiAgICBzdHJlYW1PcGVuZWQgPSBmYWxzZTtcblxuICAgIHN0YXJ0VmlkZW9DYXB0dXJlKCkge1xuICAgICAgICB0aGlzLnN0cmVhbU9wZW5lZCA9IHRydWU7XG5cbiAgICAgICAgY29uc3QgY29uc3RyYWludHMgPSB7XG4gICAgICAgICAgICBhdWRpbzogZmFsc2UsXG4gICAgICAgICAgICB2aWRlbzoge1xuICAgICAgICAgICAgICAgIHdpZHRoOiB7aWRlYWw6IDE5MjB9LFxuICAgICAgICAgICAgICAgIGhlaWdodDoge2lkZWFsOiAxMDgwfSxcbiAgICAgICAgICAgICAgICBmYWNpbmdNb2RlOiB7aWRlYWw6ICd1c2VyJ30sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuXG4gICAgICAgIG5hdmlnYXRvci5tZWRpYURldmljZXNcbiAgICAgICAgICAgIC5nZXRVc2VyTWVkaWEoY29uc3RyYWludHMpXG4gICAgICAgICAgICAudGhlbihzdHJlYW0gPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudmlkZW9TdHJlYW0gPSBzdHJlYW07XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnZpZGVvRWxlbWVudCAmJiB0aGlzLnZpZGVvRWxlbWVudC5uYXRpdmVFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZGVvRWxlbWVudC5uYXRpdmVFbGVtZW50LnNyY09iamVjdCA9IHN0cmVhbTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIDEwMCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yQ2FwdHVyZS5lbWl0KGBOZ3ggSW1hZ2UgQ29tcHJlc3M6IENvdWxkIG5vdCBhY2Nlc3MgdGhlIGNhbWVyYS4gJHtlcnJvcn1gKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbU9wZW5lZCA9IHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhY3F1aXJlSW1hZ2UoKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICBjb25zdCB2aWRlbyA9IHRoaXMudmlkZW9FbGVtZW50ICYmIHRoaXMudmlkZW9FbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGlmICghdmlkZW8pIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3JDYXB0dXJlLmVtaXQoJ05neCBJbWFnZSBDb21wcmVzcyAtIEVycm9yIGluIGFjcXVpc2l0aW9uIG9mIHZpZGVvIGVsZW1lbnQuJyk7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbU9wZW5lZCA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHZpZGVvLnZpZGVvV2lkdGg7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSB2aWRlby52aWRlb0hlaWdodDtcbiAgICAgICAgY29uc3QgY29udGV4dDJkID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIGlmIChjb250ZXh0MmQpIGNvbnRleHQyZC5kcmF3SW1hZ2UodmlkZW8sIDAsIDApO1xuICAgICAgICBjb25zdCBuZXdJbWFnZSA9IGNhbnZhcy50b0RhdGFVUkwoJ2pwZycsIDk1KTtcbiAgICAgICAgaWYgKHRoaXMudmlkZW9TdHJlYW0pIHtcbiAgICAgICAgICAgIHRoaXMudmlkZW9TdHJlYW0uZ2V0VmlkZW9UcmFja3MoKS5mb3JFYWNoKHRyYWNrID0+IHRyYWNrLnN0b3AoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbWFnZUNhcHR1cmVkLmVtaXQobmV3SW1hZ2UpO1xuICAgICAgICB0aGlzLnN0cmVhbU9wZW5lZCA9IGZhbHNlO1xuICAgIH1cbn1cbiJdfQ==