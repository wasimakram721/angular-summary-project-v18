import { Injectable } from '@angular/core';
import { ImageCompress } from './image-compress';
import { DOC_ORIENTATION } from './models/DOC_ORIENTATION';
import * as i0 from "@angular/core";
export class NgxImageCompressService {
    constructor(rendererFactory) {
        this.DOC_ORIENTATION = DOC_ORIENTATION;
        this.render = rendererFactory.createRenderer(null, null);
        this.imageCompress = new ImageCompress();
    }
    /**
     * helper to evaluate the compression rate
     * @param imgString the image in base64 string format
     */
    byteCount(image) {
        return this.imageCompress.byteCount(image);
    }
    /**
     * Get the correct Orientation value from image tags
     */
    getOrientation(file) {
        return this.imageCompress.getOrientation(file);
    }
    /**
     * return a promise with the new image data and image orientation
     * Nothing happen if no file have been selected
     */
    uploadFile() {
        return this.imageCompress.uploadFile(this.render, false);
    }
    /**
     * return a promise with an array of image data and image orientation
     * Nothing happen if no files have been selected
     */
    uploadMultipleFiles() {
        return this.imageCompress.uploadFile(this.render, true);
    }
    /**
     * return a promise with the new image data and image orientation
     * the promise will reject if no file have been selected
     */
    uploadFileOrReject() {
        return this.imageCompress.uploadFile(this.render, false, true);
    }
    /**
     * return a promise with an array of image data and image orientation
     * the promise will reject if no files have been selected
     */
    uploadMultipleFilesOrReject() {
        return this.imageCompress.uploadFile(this.render, true, true);
    }
    /**
   * perform a compression from the given DataUrl (string), provided by the uploadFile, or uploadMultipleFiles method
   *
   *
   | Parameter   | Type   | Description                                                                       |
   | ----------- | ------ | --------------------------------------------------------------------------------- |
   | image       | string | DataUrl (string) representing the image                                           |
   | orientation | number | EXIF Orientation value using the DOC_ORIENTATION enum value                       |
   | ratio       | number | Maximum scale factor as a percentage (optional, default: 50) <sup>[1](#fn1)</sup> |
   | quality     | number | JPEG quality factor as a percentage (optional, default: 50) <sup>[2](#fn2)</sup>  |
   | maxwidth    | number | Maximum width in pixels if you need to resize (optional, default: 0 - no resize)  |
   | maxheight   | number | Maximum height in pixels if you need to resize (optional, default: 0 - no resize) |
   */
    compressFile(image, orientation, ratio = 50, quality = 50, maxWidth = 0, maxHeight = 0) {
        return this.imageCompress.compress(image, orientation, this.render, ratio, quality, maxWidth, maxHeight);
    }
    /**
     * Most simple function to use here.
     * Perform an upload and return an image dataUrl (string format) with a maximum size, given in *MegaBytes*
     * If the size can't be reached, the best that can be reached will be returned in promise *rejection*
     * Put debugMode to true if you have some trouble to print some help using console.debug
     */
    uploadAndGetImageWithMaxSize(maxSizeMb = 1, debugMode = false, rejectOnCancel = false) {
        return this.imageCompress
            .uploadGetImageMaxSize(maxSizeMb, debugMode, this.render, rejectOnCancel)
            .then(uploadResponse => uploadResponse.image)
            .catch(e => {
            throw e.image;
        });
    }
    /**
     * Same as before, but return more informations (file name...)
     */
    uploadAndGetImageWithMaxSizeAndMetas(maxSizeMb = 1, debugMode = false, rejectOnCancel = false) {
        return this.imageCompress.uploadGetImageMaxSize(maxSizeMb, debugMode, this.render, rejectOnCancel);
    }
    /**
     * Not handling the upload, you need to provide the file and the orientation by yourself
     */
    getImageWithMaxSizeAndMetas(file, maxSizeMb = 1, debugMode = false) {
        return this.imageCompress.getImageMaxSize(file, maxSizeMb, debugMode, this.render);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.1.1", ngImport: i0, type: NgxImageCompressService, deps: [{ token: i0.RendererFactory2 }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.1.1", ngImport: i0, type: NgxImageCompressService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.1.1", ngImport: i0, type: NgxImageCompressService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: () => [{ type: i0.RendererFactory2 }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LWltYWdlLWNvbXByZXNzLnNlcnZpY2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9wcm9qZWN0cy9uZ3gtaW1hZ2UtY29tcHJlc3Mvc3JjL2xpYi9uZ3gtaW1hZ2UtY29tcHJlc3Muc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUMsVUFBVSxFQUE4QixNQUFNLGVBQWUsQ0FBQztBQUN0RSxPQUFPLEVBQUMsYUFBYSxFQUFDLE1BQU0sa0JBQWtCLENBQUM7QUFFL0MsT0FBTyxFQUFDLGVBQWUsRUFBQyxNQUFNLDBCQUEwQixDQUFDOztBQU16RCxNQUFNLE9BQU8sdUJBQXVCO0lBT2hDLFlBQVksZUFBaUM7UUFGdEMsb0JBQWUsR0FBRyxlQUFlLENBQUM7UUFHckMsSUFBSSxDQUFDLE1BQU0sR0FBRyxlQUFlLENBQUMsY0FBYyxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztRQUN6RCxJQUFJLENBQUMsYUFBYSxHQUFHLElBQUksYUFBYSxFQUFFLENBQUM7SUFDN0MsQ0FBQztJQUVEOzs7T0FHRztJQUNJLFNBQVMsQ0FBQyxLQUFjO1FBQzNCLE9BQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDL0MsQ0FBQztJQUVEOztPQUVHO0lBQ0ksY0FBYyxDQUFDLElBQVU7UUFDNUIsT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNuRCxDQUFDO0lBRUQ7OztPQUdHO0lBQ0ksVUFBVTtRQUNiLE9BQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxLQUFLLENBQTRCLENBQUM7SUFDeEYsQ0FBQztJQUVEOzs7T0FHRztJQUNJLG1CQUFtQjtRQUN0QixPQUFPLElBQUksQ0FBQyxhQUFhLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUE4QixDQUFDO0lBQ3pGLENBQUM7SUFFRDs7O09BR0c7SUFDSSxrQkFBa0I7UUFDckIsT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLEtBQUssRUFBRSxJQUFJLENBQTRCLENBQUM7SUFDOUYsQ0FBQztJQUVEOzs7T0FHRztJQUNJLDJCQUEyQjtRQUM5QixPQUFPLElBQUksQ0FBQyxhQUFhLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBOEIsQ0FBQztJQUMvRixDQUFDO0lBRUQ7Ozs7Ozs7Ozs7OztLQVlDO0lBQ00sWUFBWSxDQUNmLEtBQWMsRUFDZCxXQUE0QixFQUM1QixLQUFLLEdBQUcsRUFBRSxFQUNWLE9BQU8sR0FBRyxFQUFFLEVBQ1osUUFBUSxHQUFHLENBQUMsRUFDWixTQUFTLEdBQUcsQ0FBQztRQUViLE9BQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQyxRQUFRLENBQUMsS0FBSyxFQUFFLFdBQVcsRUFBRSxJQUFJLENBQUMsTUFBTSxFQUFFLEtBQUssRUFBRSxPQUFPLEVBQUUsUUFBUSxFQUFFLFNBQVMsQ0FBQyxDQUFDO0lBQzdHLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNJLDRCQUE0QixDQUFDLFNBQVMsR0FBRyxDQUFDLEVBQUUsU0FBUyxHQUFHLEtBQUssRUFBRSxjQUFjLEdBQUcsS0FBSztRQUN4RixPQUFPLElBQUksQ0FBQyxhQUFhO2FBQ3BCLHFCQUFxQixDQUFDLFNBQVMsRUFBRSxTQUFTLEVBQUUsSUFBSSxDQUFDLE1BQU0sRUFBRSxjQUFjLENBQUM7YUFDeEUsSUFBSSxDQUFDLGNBQWMsQ0FBQyxFQUFFLENBQUMsY0FBYyxDQUFDLEtBQUssQ0FBQzthQUM1QyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUU7WUFDUCxNQUFNLENBQUMsQ0FBQyxLQUFLLENBQUM7UUFDbEIsQ0FBQyxDQUFDLENBQUM7SUFDWCxDQUFDO0lBRUQ7O09BRUc7SUFDSSxvQ0FBb0MsQ0FBQyxTQUFTLEdBQUcsQ0FBQyxFQUFFLFNBQVMsR0FBRyxLQUFLLEVBQUUsY0FBYyxHQUFHLEtBQUs7UUFDaEcsT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDLHFCQUFxQixDQUFDLFNBQVMsRUFBRSxTQUFTLEVBQUUsSUFBSSxDQUFDLE1BQU0sRUFBRSxjQUFjLENBQUMsQ0FBQztJQUN2RyxDQUFDO0lBRUQ7O09BRUc7SUFDSSwyQkFBMkIsQ0FBQyxJQUFvQixFQUFFLFNBQVMsR0FBRyxDQUFDLEVBQUUsU0FBUyxHQUFHLEtBQUs7UUFDckYsT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDLGVBQWUsQ0FBQyxJQUFJLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDdkYsQ0FBQzs4R0E5R1EsdUJBQXVCO2tIQUF2Qix1QkFBdUIsY0FGcEIsTUFBTTs7MkZBRVQsdUJBQXVCO2tCQUhuQyxVQUFVO21CQUFDO29CQUNSLFVBQVUsRUFBRSxNQUFNO2lCQUNyQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7SW5qZWN0YWJsZSwgUmVuZGVyZXIyLCBSZW5kZXJlckZhY3RvcnkyfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7SW1hZ2VDb21wcmVzc30gZnJvbSAnLi9pbWFnZS1jb21wcmVzcyc7XG5pbXBvcnQge0RhdGFVcmx9IGZyb20gJy4vbW9kZWxzL2RhdGEtdXJsJztcbmltcG9ydCB7RE9DX09SSUVOVEFUSU9OfSBmcm9tICcuL21vZGVscy9ET0NfT1JJRU5UQVRJT04nO1xuaW1wb3J0IHtVcGxvYWRSZXNwb25zZX0gZnJvbSAnLi9tb2RlbHMvdXBsb2FkLXJlc3BvbnNlJztcblxuQEluamVjdGFibGUoe1xuICAgIHByb3ZpZGVkSW46ICdyb290Jyxcbn0pXG5leHBvcnQgY2xhc3MgTmd4SW1hZ2VDb21wcmVzc1NlcnZpY2Uge1xuICAgIHByaXZhdGUgcmVhZG9ubHkgcmVuZGVyOiBSZW5kZXJlcjI7XG5cbiAgICBwcml2YXRlIGltYWdlQ29tcHJlc3M6IEltYWdlQ29tcHJlc3M7XG5cbiAgICBwdWJsaWMgRE9DX09SSUVOVEFUSU9OID0gRE9DX09SSUVOVEFUSU9OO1xuXG4gICAgY29uc3RydWN0b3IocmVuZGVyZXJGYWN0b3J5OiBSZW5kZXJlckZhY3RvcnkyKSB7XG4gICAgICAgIHRoaXMucmVuZGVyID0gcmVuZGVyZXJGYWN0b3J5LmNyZWF0ZVJlbmRlcmVyKG51bGwsIG51bGwpO1xuICAgICAgICB0aGlzLmltYWdlQ29tcHJlc3MgPSBuZXcgSW1hZ2VDb21wcmVzcygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGhlbHBlciB0byBldmFsdWF0ZSB0aGUgY29tcHJlc3Npb24gcmF0ZVxuICAgICAqIEBwYXJhbSBpbWdTdHJpbmcgdGhlIGltYWdlIGluIGJhc2U2NCBzdHJpbmcgZm9ybWF0XG4gICAgICovXG4gICAgcHVibGljIGJ5dGVDb3VudChpbWFnZTogRGF0YVVybCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbWFnZUNvbXByZXNzLmJ5dGVDb3VudChpbWFnZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjb3JyZWN0IE9yaWVudGF0aW9uIHZhbHVlIGZyb20gaW1hZ2UgdGFnc1xuICAgICAqL1xuICAgIHB1YmxpYyBnZXRPcmllbnRhdGlvbihmaWxlOiBGaWxlKTogUHJvbWlzZTxET0NfT1JJRU5UQVRJT04+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW1hZ2VDb21wcmVzcy5nZXRPcmllbnRhdGlvbihmaWxlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZXR1cm4gYSBwcm9taXNlIHdpdGggdGhlIG5ldyBpbWFnZSBkYXRhIGFuZCBpbWFnZSBvcmllbnRhdGlvblxuICAgICAqIE5vdGhpbmcgaGFwcGVuIGlmIG5vIGZpbGUgaGF2ZSBiZWVuIHNlbGVjdGVkXG4gICAgICovXG4gICAgcHVibGljIHVwbG9hZEZpbGUoKTogUHJvbWlzZTxVcGxvYWRSZXNwb25zZT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5pbWFnZUNvbXByZXNzLnVwbG9hZEZpbGUodGhpcy5yZW5kZXIsIGZhbHNlKSBhcyBQcm9taXNlPFVwbG9hZFJlc3BvbnNlPjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZXR1cm4gYSBwcm9taXNlIHdpdGggYW4gYXJyYXkgb2YgaW1hZ2UgZGF0YSBhbmQgaW1hZ2Ugb3JpZW50YXRpb25cbiAgICAgKiBOb3RoaW5nIGhhcHBlbiBpZiBubyBmaWxlcyBoYXZlIGJlZW4gc2VsZWN0ZWRcbiAgICAgKi9cbiAgICBwdWJsaWMgdXBsb2FkTXVsdGlwbGVGaWxlcygpOiBQcm9taXNlPFVwbG9hZFJlc3BvbnNlW10+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW1hZ2VDb21wcmVzcy51cGxvYWRGaWxlKHRoaXMucmVuZGVyLCB0cnVlKSBhcyBQcm9taXNlPFVwbG9hZFJlc3BvbnNlW10+O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJldHVybiBhIHByb21pc2Ugd2l0aCB0aGUgbmV3IGltYWdlIGRhdGEgYW5kIGltYWdlIG9yaWVudGF0aW9uXG4gICAgICogdGhlIHByb21pc2Ugd2lsbCByZWplY3QgaWYgbm8gZmlsZSBoYXZlIGJlZW4gc2VsZWN0ZWRcbiAgICAgKi9cbiAgICBwdWJsaWMgdXBsb2FkRmlsZU9yUmVqZWN0KCk6IFByb21pc2U8VXBsb2FkUmVzcG9uc2U+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW1hZ2VDb21wcmVzcy51cGxvYWRGaWxlKHRoaXMucmVuZGVyLCBmYWxzZSwgdHJ1ZSkgYXMgUHJvbWlzZTxVcGxvYWRSZXNwb25zZT47XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIGEgcHJvbWlzZSB3aXRoIGFuIGFycmF5IG9mIGltYWdlIGRhdGEgYW5kIGltYWdlIG9yaWVudGF0aW9uXG4gICAgICogdGhlIHByb21pc2Ugd2lsbCByZWplY3QgaWYgbm8gZmlsZXMgaGF2ZSBiZWVuIHNlbGVjdGVkXG4gICAgICovXG4gICAgcHVibGljIHVwbG9hZE11bHRpcGxlRmlsZXNPclJlamVjdCgpOiBQcm9taXNlPFVwbG9hZFJlc3BvbnNlW10+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW1hZ2VDb21wcmVzcy51cGxvYWRGaWxlKHRoaXMucmVuZGVyLCB0cnVlLCB0cnVlKSBhcyBQcm9taXNlPFVwbG9hZFJlc3BvbnNlW10+O1xuICAgIH1cblxuICAgIC8qKlxuICAgKiBwZXJmb3JtIGEgY29tcHJlc3Npb24gZnJvbSB0aGUgZ2l2ZW4gRGF0YVVybCAoc3RyaW5nKSwgcHJvdmlkZWQgYnkgdGhlIHVwbG9hZEZpbGUsIG9yIHVwbG9hZE11bHRpcGxlRmlsZXMgbWV0aG9kXG4gICAqXG4gICAqXG4gICB8IFBhcmFtZXRlciAgIHwgVHlwZSAgIHwgRGVzY3JpcHRpb24gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgIHwgLS0tLS0tLS0tLS0gfCAtLS0tLS0gfCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gfFxuICAgfCBpbWFnZSAgICAgICB8IHN0cmluZyB8IERhdGFVcmwgKHN0cmluZykgcmVwcmVzZW50aW5nIHRoZSBpbWFnZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICB8IG9yaWVudGF0aW9uIHwgbnVtYmVyIHwgRVhJRiBPcmllbnRhdGlvbiB2YWx1ZSB1c2luZyB0aGUgRE9DX09SSUVOVEFUSU9OIGVudW0gdmFsdWUgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgIHwgcmF0aW8gICAgICAgfCBudW1iZXIgfCBNYXhpbXVtIHNjYWxlIGZhY3RvciBhcyBhIHBlcmNlbnRhZ2UgKG9wdGlvbmFsLCBkZWZhdWx0OiA1MCkgPHN1cD5bMV0oI2ZuMSk8L3N1cD4gfFxuICAgfCBxdWFsaXR5ICAgICB8IG51bWJlciB8IEpQRUcgcXVhbGl0eSBmYWN0b3IgYXMgYSBwZXJjZW50YWdlIChvcHRpb25hbCwgZGVmYXVsdDogNTApIDxzdXA+WzJdKCNmbjIpPC9zdXA+ICB8XG4gICB8IG1heHdpZHRoICAgIHwgbnVtYmVyIHwgTWF4aW11bSB3aWR0aCBpbiBwaXhlbHMgaWYgeW91IG5lZWQgdG8gcmVzaXplIChvcHRpb25hbCwgZGVmYXVsdDogMCAtIG5vIHJlc2l6ZSkgIHxcbiAgIHwgbWF4aGVpZ2h0ICAgfCBudW1iZXIgfCBNYXhpbXVtIGhlaWdodCBpbiBwaXhlbHMgaWYgeW91IG5lZWQgdG8gcmVzaXplIChvcHRpb25hbCwgZGVmYXVsdDogMCAtIG5vIHJlc2l6ZSkgfFxuICAgKi9cbiAgICBwdWJsaWMgY29tcHJlc3NGaWxlKFxuICAgICAgICBpbWFnZTogRGF0YVVybCxcbiAgICAgICAgb3JpZW50YXRpb246IERPQ19PUklFTlRBVElPTixcbiAgICAgICAgcmF0aW8gPSA1MCxcbiAgICAgICAgcXVhbGl0eSA9IDUwLFxuICAgICAgICBtYXhXaWR0aCA9IDAsXG4gICAgICAgIG1heEhlaWdodCA9IDBcbiAgICApOiBQcm9taXNlPERhdGFVcmw+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW1hZ2VDb21wcmVzcy5jb21wcmVzcyhpbWFnZSwgb3JpZW50YXRpb24sIHRoaXMucmVuZGVyLCByYXRpbywgcXVhbGl0eSwgbWF4V2lkdGgsIG1heEhlaWdodCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTW9zdCBzaW1wbGUgZnVuY3Rpb24gdG8gdXNlIGhlcmUuXG4gICAgICogUGVyZm9ybSBhbiB1cGxvYWQgYW5kIHJldHVybiBhbiBpbWFnZSBkYXRhVXJsIChzdHJpbmcgZm9ybWF0KSB3aXRoIGEgbWF4aW11bSBzaXplLCBnaXZlbiBpbiAqTWVnYUJ5dGVzKlxuICAgICAqIElmIHRoZSBzaXplIGNhbid0IGJlIHJlYWNoZWQsIHRoZSBiZXN0IHRoYXQgY2FuIGJlIHJlYWNoZWQgd2lsbCBiZSByZXR1cm5lZCBpbiBwcm9taXNlICpyZWplY3Rpb24qXG4gICAgICogUHV0IGRlYnVnTW9kZSB0byB0cnVlIGlmIHlvdSBoYXZlIHNvbWUgdHJvdWJsZSB0byBwcmludCBzb21lIGhlbHAgdXNpbmcgY29uc29sZS5kZWJ1Z1xuICAgICAqL1xuICAgIHB1YmxpYyB1cGxvYWRBbmRHZXRJbWFnZVdpdGhNYXhTaXplKG1heFNpemVNYiA9IDEsIGRlYnVnTW9kZSA9IGZhbHNlLCByZWplY3RPbkNhbmNlbCA9IGZhbHNlKTogUHJvbWlzZTxEYXRhVXJsPiB7XG4gICAgICAgIHJldHVybiB0aGlzLmltYWdlQ29tcHJlc3NcbiAgICAgICAgICAgIC51cGxvYWRHZXRJbWFnZU1heFNpemUobWF4U2l6ZU1iLCBkZWJ1Z01vZGUsIHRoaXMucmVuZGVyLCByZWplY3RPbkNhbmNlbClcbiAgICAgICAgICAgIC50aGVuKHVwbG9hZFJlc3BvbnNlID0+IHVwbG9hZFJlc3BvbnNlLmltYWdlKVxuICAgICAgICAgICAgLmNhdGNoKGUgPT4ge1xuICAgICAgICAgICAgICAgIHRocm93IGUuaW1hZ2U7XG4gICAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTYW1lIGFzIGJlZm9yZSwgYnV0IHJldHVybiBtb3JlIGluZm9ybWF0aW9ucyAoZmlsZSBuYW1lLi4uKVxuICAgICAqL1xuICAgIHB1YmxpYyB1cGxvYWRBbmRHZXRJbWFnZVdpdGhNYXhTaXplQW5kTWV0YXMobWF4U2l6ZU1iID0gMSwgZGVidWdNb2RlID0gZmFsc2UsIHJlamVjdE9uQ2FuY2VsID0gZmFsc2UpOiBQcm9taXNlPFVwbG9hZFJlc3BvbnNlPiB7XG4gICAgICAgIHJldHVybiB0aGlzLmltYWdlQ29tcHJlc3MudXBsb2FkR2V0SW1hZ2VNYXhTaXplKG1heFNpemVNYiwgZGVidWdNb2RlLCB0aGlzLnJlbmRlciwgcmVqZWN0T25DYW5jZWwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE5vdCBoYW5kbGluZyB0aGUgdXBsb2FkLCB5b3UgbmVlZCB0byBwcm92aWRlIHRoZSBmaWxlIGFuZCB0aGUgb3JpZW50YXRpb24gYnkgeW91cnNlbGZcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0SW1hZ2VXaXRoTWF4U2l6ZUFuZE1ldGFzKGZpbGU6IFVwbG9hZFJlc3BvbnNlLCBtYXhTaXplTWIgPSAxLCBkZWJ1Z01vZGUgPSBmYWxzZSk6IFByb21pc2U8VXBsb2FkUmVzcG9uc2U+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW1hZ2VDb21wcmVzcy5nZXRJbWFnZU1heFNpemUoZmlsZSwgbWF4U2l6ZU1iLCBkZWJ1Z01vZGUsIHRoaXMucmVuZGVyKTtcbiAgICB9XG59XG4iXX0=